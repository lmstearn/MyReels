; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
#define MyAppName "MyReels"
#define MyAppVersion "3.0"
#define MyAppPublisher "Stearn & DisAssoc"
#define MyAppURL "https://github.com/lmstearn/MyReels/wiki"
#define MyAppExeName "MyReels.exe"
#define MyAppUpdaterName "MyReelsUpdater"
#define MyAppUpdaterExeName "MyReelsUpdater.exe"
#define MyAppSysExeName "SetupMyReelsSys.exe"

;AppSupportURL
;AppUpdatesURL

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
PrivilegesRequired=lowest
AppId={{7FE3CDE1-00A9-491F-B856-E3A121405B49}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
;AppMutex=20b70e57-1c2e-4de9-99e5-20f3961e6912
AppMutex=20b70e57-1c2e-4de9-99e5-20f3961e6812,Global\20b70e57-1c2e-4de9-99e5-20f3961e6912
;https://stackoverflow.com/questions/28628699/inno-setup-prevent-executing-the-installer-multiple-times-simultaneosly
SetupMutex=SetupMutex{#SetupSetting("AppId")}

;The following setting may change see repair/modify section below
AppModifyPath="{app}\{#MyAppUpdaterExeName}" /modify=1

CloseApplications=force
DefaultDirName=C:\games\{#MyAppName}
DefaultGroupName={#MyAppName}
; Note: The Installer script resides in the Installer directory!
LicenseFile=I:\games\{#MyAppName}\Licence.txt
OutputDir=I:\games\{#MyAppName}\Installer
OutputBaseFilename=Setup{#MyAppName}
Compression=lzma
SolidCompression=yes
SetupIconFile=CaveMantizardum.ico
WizardImageFile=Installed.bmp
;Using custom Language
ShowLanguageDialog=no
;This by default but...
UsePreviousAppDir=yes
RestartApplications=False
MinVersion=0,5.01
AppReadmeFile=Readme.txt

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
;not needed
;Name: "quicklaunchicon"; Description: "{cm:CreateQuickLaunchIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "VclStylesinno.dll"; DestDir: "{app}"; Flags: dontcopy
Source: "SapphireKamri.vsf"; DestDir: "{app}"; Flags: dontcopy
Source: "{#MyAppSysExeName}"; DestDir: "{tmp}"; Flags: deleteafterinstall


Source: "..\{#MyAppExeName}"; DestDir: "{app}"; Flags: touch promptifolder replacesameversion; Components: program
Source: "Configuration\slotdata.s$t"; DestDir: "{app}"; Flags: touch; Components: program\configuration
Source: "{#MyAppUpdaterExeName}"; DestDir: "{app}"; Flags: touch; Components: program
;ignore ignoreversion flag for the time being
Source: "..\{#MyAppName}.chm"; DestDir: "{app}"; Flags: touch; Components: help
Source: "Readme.txt"; DestDir: "{app}"; Flags: isreadme; Components: Readme
Source: "Default\*.mid"; DestDir: "{app}"; Flags: touch; Components: midi\default
Source: "Originals\*.mid"; DestDir: "{app}"; Flags: touch; Components: midi\original
Source: "..\*"; DestDir: "{app}"; Flags: touch; Excludes: "slotdata.s$t"

[Dirs]
;Name: "{userappdata}\Microsoft\Internet Explorer\Quick Launch\{#MyAppName}"

[Icons]
Name: "{commondesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon
;Name: "{userappdata}\Microsoft\Internet Explorer\Quick Launch\{#MyAppName}\{#MyAppName}"; Filename: "{#MyAppExeName}"; Tasks: quicklaunchicon

Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; WorkingDir: "{app}"
Name: "{group}\{#MyAppUpdaterName}"; Filename: "{app}\{#MyAppUpdaterExeName}"; WorkingDir: "{app}"
[Registry]
Root: HKCU; Subkey: "Software\{#MyAppPublisher}\{#MyAppName}"; Flags: uninsdeletekey
Root: HKCU; Subkey: "Software\{#MyAppPublisher}\{#MyAppName}"; ValueType: string; ValueName: "Name"; ValueData: "{app}";

;Association done in program
;Root: HKCR; Subkey: ".s$t";ValueData: "{#MyAppName}";Flags: uninsdeletevalue; ValueType: string; ValueName: ""
;Root: HKCR; Subkey: "{#MyAppName}";ValueData: "Program {#MyAppName}";	Flags: uninsdeletekey; ValueType: string; ValueName: ""
;Root: HKCR; Subkey: "{#MyAppName}\DefaultIcon";ValueData: "{app}\{#MyAppExeName},0";ValueType: string; ValueName: ""
;Root: HKCR; Subkey: "{#MyAppName}\shell\open\command";ValueData: """{app}\{#MyAppExeName}"" ""%1""";ValueType: string;ValueName: ""

[Components]
Name: "program"; Description: "Program Files"; Types: full compact custom; Flags: fixed
Name: "program\configuration"; Description: "s$t File"; Types: full compact custom; Flags: fixed
Name: "help"; Description: "Help File"; Types: full; Flags: disablenouninstallwarning
Name: "Readme"; Description: "Readme Text File"; Flags: disablenouninstallwarning
Name: "midi"; Description: "Midi Files"; Types: full; Flags: disablenouninstallwarning
Name: "midi\default"; Description: "Default"; Types: full; Flags: exclusive disablenouninstallwarning
Name: "midi\original"; Description: "Originals (Monstrosities bundled with earlier versions)"; Types: full; Flags: exclusive disablenouninstallwarning

[Run]
Filename: "{tmp}\{#MyAppSysExeName}"; Parameters: "/silent"; Flags: waituntilterminated shellexec; Description: "Install {#MyAppName} sys files"; StatusMsg: "Installing {#MyAppName} sys files ..."; Verb: "runas"
;also want to prompt for updater?
Filename: "{app}\{#MyAppUpdaterExeName}"; Flags: nowait postinstall skipifsilent; Description: "{cm:UpdateProgram,{#StringChange(MyAppName, '&', '&&')}}"
Filename: "{app}\{#MyAppExeName}"; Flags: nowait postinstall skipifsilent; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"

[Languages]
Name: "en"; MessagesFile: "compiler:Default.isl"
Name: "cs"; MessagesFile: "compiler:Languages\Czech.isl"
Name: "deu"; MessagesFile: "compiler:Languages\German.isl"
Name: "es"; MessagesFile: "compiler:Languages\Spanish.isl"

[Messages]
SetupAppTitle=Setup{#MyAppName}
SetupAppRunningError=Setup has detected that %1 is currently running.%n%nPlease close all instances of it now, then click OK to continue, or Cancel to exit.
SelectStartMenuFolderBrowseLabel=To continue, click Next.%nModifying the {#MyAppName} folder will break custom shortcuts for new Profile Configs.%nThus clicking Browse to select a different folder is not recommended!
DirExists=The folder:%n%n%1%n%nalready exists. If another user has installed {#MyAppName} there,%nsharing this folder is recommended for advanced users only.%nAlso refer to the Installation section in the help file.%n%nWould you like to install to that folder anyway?

[UninstallDelete]
Type: files; Name: "{#MyAppName}.chw"
Type: files; Name: "q0.bmp"

[CustomMessages]
UpdateProgram=Update %1 Now
; For Repair
OptionsFormCaption=Setup options...
RepairButtonCaption=Repair
UninstallButtonCaption=Uninstall



[Code]
const
NL = #13#10;    //carriage return and line feed
MAX_PATH = 260; //Love it

mrRepair = 100;
mrUninstall = 101;

// Import the LoadVCLStyle function from VclStylesInno.DLL
var
RunListModified: Boolean;
procedure LoadVCLStyle(VClStyleFile: String); external 'LoadVCLStyleW@files:VclStylesInno.dll stdcall';
// Import the UnLoadVCLStyles function from VclStylesInno.DLL
procedure UnLoadVCLStyles; external 'UnLoadVCLStyles@files:VclStylesInno.dll stdcall';

// https://stackoverflow.com/questions/1193873/which-reasons-could-make-shellexecute-fail/44765636#44765636
function ShellExecute(hwnd: HWND; lpOperation: string; lpFile: string;
  lpParameters: string; lpDirectory: string; nShowCmd: Integer): THandle;
  external 'ShellExecuteW@shell32.dll stdcall';



// https://stackoverflow.com/questions/41021292/inno-setup-language-selector-with-vcl-styles/41021514#comment76511928_41021514
procedure SelectLanguage();
var
  LanguageForm: TSetupForm;
  CancelButton: TNewButton;
  OKButton: TNewButton;
  LangCombo: TNewComboBox;
  SelectLabel: TNewStaticText;
  Languages: TStrings;
  Params: string;
  Instance: THandle;
  P, I: Integer;
  S, L: string;
begin
  Languages := TStringList.Create();
  Languages.Add('en=English');
  Languages.Add('deu=German');
  Languages.Add('es=Spanish');
  Languages.Add('cs='+#$010C+'e'+#$0161+'tina');
  LanguageForm := CreateCustomForm;

  LanguageForm.Caption := SetupMessage(msgSelectLanguageTitle);
  LanguageForm.ClientWidth := ScaleX(297);
  LanguageForm.ClientHeight := ScaleY(125);
  LanguageForm.BorderStyle := bsDialog;
  LanguageForm.Center;

  CancelButton := TNewButton.Create(LanguageForm);
  CancelButton.Parent := LanguageForm;
  CancelButton.Left := ScaleX(214);
  CancelButton.Top := ScaleY(93);
  CancelButton.Width := ScaleY(75);
  CancelButton.Height := ScaleY(23);
  CancelButton.TabOrder := 3;
  CancelButton.ModalResult := mrCancel;
  CancelButton.Caption := SetupMessage(msgButtonCancel);

  OKButton := TNewButton.Create(LanguageForm);
  OKButton.Parent := LanguageForm;
  OKButton.Left := ScaleX(133);
  OKButton.Top := ScaleY(93);
  OKButton.Width := ScaleX(75);
  OKButton.Height := ScaleY(23);
  OKButton.Caption := SetupMessage(msgButtonOK);
  OKButton.Default := True
  OKButton.ModalResult := mrOK;
  OKButton.TabOrder := 2;

  LangCombo := TNewComboBox.Create(LanguageForm);
  LangCombo.Parent := LanguageForm;
  LangCombo.Left := ScaleX(16);
  LangCombo.Top := ScaleY(56);
  LangCombo.Width := ScaleX(273);
  LangCombo.Height := ScaleY(21);
  LangCombo.Style := csDropDownList;
  LangCombo.DropDownCount := 16;
  LangCombo.TabOrder := 1;

  SelectLabel := TNewStaticText.Create(LanguageForm);
  SelectLabel.Parent := LanguageForm;
  SelectLabel.Left := ScaleX(16);
  SelectLabel.Top := ScaleY(8);
  SelectLabel.Width := ScaleX(273);
  SelectLabel.Height := ScaleY(39);
  SelectLabel.AutoSize := False
  SelectLabel.Caption := SetupMessage(msgSelectLanguageLabel);
  SelectLabel.TabOrder := 0;
  SelectLabel.WordWrap := True;

  for I := 0 to Languages.Count - 1 do
  begin
    P := Pos('=', Languages.Strings[I]);
    L := Copy(Languages.Strings[I], 0, P - 1);
    S := Copy(Languages.Strings[I], P + 1, Length(Languages.Strings[I]) - P);
    LangCombo.Items.Add(S);
    if L = ActiveLanguage then LangCombo.ItemIndex := I;
    end;

  if LanguageForm.ShowModal = mrOK then
  begin
    { Collect current instance parameters }
    for I := 1 to ParamCount do
    begin
      S := ParamStr(I);
      { Unique log file name for the elevated instance }
      if CompareText(Copy(S, 1, 5), '/LOG=') = 0 then
      begin
        S := S + '-localized';
      end;
      { Do not pass our /SL5 switch }
      if CompareText(Copy(S, 1, 5), '/SL5=') <> 0 then
      begin
        Params := Params + AddQuotes(S) + ' ';
      end;
    end;

    L := Languages.Strings[LangCombo.ItemIndex];
    P := Pos('=', L);
    L := Copy(L, 0, P-1);

    { ... and add selected language }
    Params := Params + '/LANG=' + L;
    Instance := ShellExecute(0, '', ExpandConstant('{srcexe}'), Params, '', SW_SHOW);
    //
    //
    if Instance <= 32 then
    begin
      MsgBox(
        Format({srcexe}+ 'Running installer with selected language failed. Code: %d', [Instance]),
        mbError, MB_OK);
    end;
  end;
end;


/////////////////////////////////////////////////////////////////////
function GetUninstallString(): String;
var
  sUnInstPath: String;
  sUnInstallString: String;

begin
  sUnInstPath:= ExpandConstant('Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppName}');
  sUnInstallString := '';
  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then
    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);
    if sUnInstallString = '' Then
    Begin
    sUnInstPath:= ExpandConstant('Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppName}');
    RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString);
    End;
  Result:= sUnInstallString;
end;


/////////////////////////////////////////////////////////////////////
function IsUpgrade(): Boolean;
begin
  Result := (GetUninstallString() <> '');
end;


/////////////////////////////////////////////////////////////////////
function UnInstallOldVersion(): Integer;
var
  sUnInstallString: String;
  iResultCode: Integer;
  sUnInstallStringPrm: String;
  begin
// Return Values:
// 1 - uninstall string is empty
// 2 - error executing the UnInstallString
// 3 - successfully executed the UnInstallString

  // default return value
  Result := 0;

  // get the uninstall string of the old app
  sUnInstallString := GetUninstallString();
    if sUnInstallString <> '' then
    begin
    sUnInstallStringPrm:= copy(sUnInstallString, pos(' ', sUnInstallString) + 1, MAX_PATH);
    Delete(sUnInstallString, pos(' ', sUnInstallString), MAX_PATH);
    if ExtractFileName(sUnInstallString) <> 'UNWISE.EXE' Then 
    Begin
    Result:= 1;
    Exit;
    End;
  
    MsgBox('An ancient version of MyReels detected! Click OK to commence uninstall but note:' +NL+ 'You will probably get a prompt to run as admin, unless already elevated.' +NL+ 'If choosing custom uninstall do not choose rollback system files!' +NL+ 'If there is a restart computer prompt, do not restart now! It is only for the UNWISE.EXE, old MyReels FTS and GID files which may be already deleted.' +NL+ 'Do not cancel the uninstall particularly if the directory you have just selected was used as the MyReels base directory!', mbInformation, MB_OK);
    sUnInstallString := RemoveQuotes(sUnInstallString);
    if ShellExec('open', sUnInstallString, sUnInstallStringPrm,'', SW_SHOW, ewWaitUntilTerminated, iResultCode) then
      Result:= 3
    else
      Result:= 2;

     if MsgBox('Deleting the old MyReels backup folder is recommended:', mbConfirmation, MB_YESNO) = IDYES Then
     DelTree(ExpandConstant('{app}\BACKUP'), True, True, True);
    end
    else
    Result:= 1;
end;

/////////////////////////////////////////////////////////////////////
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if (CurStep=ssInstall) then
  begin
    if (IsUpgrade()) then
    begin
      UnInstallOldVersion();
    end;
  end;
end;
//The above from https://stackoverflow.com/a/2099805/850848



//*********************************************************************************
//gets language used in the setup. returns language code in lower case
//*********************************************************************************
function GetLangCode(): String;
begin
  Result:= Lowercase( ExpandConstant('{language}') )
end;
procedure ErrMsg(fName: String);
var
sTxt: String;
//error msg function
begin
  case GetLangCode of
     'es','es2': //spanish
    begin
        sTxt:= 'Se ha producido un error en la eliminación de ' +fname+ ': causa desconocida.';
    end;
    'deu':       //german
    begin
        sTxt:= 'Fehler löschen von ' +fname+ ': Ursache Unbekannt.';
    end;
  else          //en = the default is english or other unknown language
    begin
       sTxt:= 'Delete of ' +fname+ ' failed: Reason Unknown.';
    end;
  end;
MsgBox(sTxt, mbInformation, MB_OK);
end;
//**************************\\\
//***uninstallation stuff***\\\
//**************************\\\

//confirm file deletion and then delete the file
function DeleteOneFile(sFullFilePath: String; isDir: Boolean): Boolean;
begin
if (isDir = True) Then
  Result:= DelTree(sFullFilePath, True, True, True)
else
  Result:= DeleteFile(sFullFilePath);
end;
function PrepDeleteOneFile(sFullFilePath: String; isDir: Boolean; confirm: Boolean; confirmMany: Boolean): Integer;
// return value
//-4 fail on delete confirmMany RepeatPrompt true
//-3 fail on delete confirmMany true
//-2 fail on delete confirm false
//-1 fail on delete confirm true
//no deletion here
//1 succeed on delete confirm true
//2 succeed on delete confirm false
//3 succeed on delete confirmMany true
//4 succeed on delete confirmMany RepeatPrompt true
var
  sTxt: String;
  SucInDel: Integer;
begin
  //get language specific text strings
if confirm = true then
Begin

  case GetLangCode of
    'es','es2': //spanish
    begin
      if (isDir = True) Then
      Begin
        sTxt:= 'El elemento Directorio: ' +sFullFilePath+ '' +NL+ ' Todavía está presente pero ya no es necesario por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
      end
      else
      begin
        sTxt:= 'El elemento del archivo.' +NL+ ' Todavía está presente pero ya no es necesario por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
      end;
    end;
    'deu':       //german
    begin
      if (isDir = True) Then
      begin
        sTxt:= 'Das Verzeichnis item: ' +sFullFilePath+ '' +NL+ ' Ist noch verfügbar, aber länger verlangt vom Programm.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
      end
      else
      begin
        sTxt:= 'Das Dateiposition: ' +sFullFilePath+ '' +NL+ ' Ist noch verfügbar, aber länger verlangt vom Programm.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
      end;
    end;
  else          //en = the default is english or other unknown language
  Begin
     if (isDir = True) Then
     begin
     sTxt:= 'The Directory item: ' +sFullFilePath+ +NL+ 'and its contents are no longer needed by the program.' +NL+ 'Click Yes to delete all such MyApp directories, click No to continue prompt for deletion of each directory or Cancel to keep them.';
     end
     else
     begin
     sTxt:= 'The file item: ' +sFullFilePath+ '' +NL+ 'is no longer needed by the program.' +NL+ 'Click Yes to delete all such MyApp files, click No to continue prompt for deletion of each one or Cancel to keep them.';
     end;
  End;
  end; //case


  case MsgBox(sTxt, mbConfirmation, MB_YESNOCANCEL) of
  IDYES:
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 1;
        end
        else
        begin
        SucInDel:= -1;
        end;
     End;
  IDNO:
  // user pressed No
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 2;
        end
        else
        begin
        SucInDel:= -2;
        end;
     End;
  IDCANCEL:
     Begin
     // user pressed Cancel
     SucInDel:= 0;
     End;
  End;
End

Else
Begin

  if confirmMany = True then
  Begin
    case GetLangCode of
      'es','es2': //spanish
        begin
          if (isDir = True) Then
          Begin
            sTxt:= 'Uno o más directorios creados por MyApp, el primero de los cuales es: ' +sFullFilePath+ '' +NL+ ' Todavía están presentes pero son más necesarios por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
          end
          else
          begin
            sTxt:= 'Este Archivos o enlaces de usuario todavía está presente y ya no es necesario por el programa.' +NL+ ' Todavía están presentes pero son más necesarios por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
          end;
        end;   
      'deu':       //german
        begin
          if (isDir = True) Then
          begin
            sTxt:= 'Ein oder mehrere Verzeichnisse von MyApp erstellt, die erste davon ist: ' +sFullFilePath+ '' +NL+ ' Sind noch vorhanden, werden aber länger vom Programm benötigt.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
          end
          else
          begin
            sTxt:= 'Ein oder mehrere Dateien oder Links von MyApp erstellt, die erste davon ist: ' +sFullFilePath+ '' +NL+ '  Sind noch vorhanden, werden aber länger vom Programm benötigt.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
          end;
        end;
      else          //en = the default is english or other unknown language
      begin
          if (isDir = True) Then
          begin
            sTxt:= 'One or more directories created by MyApp, the first of which is: ' +sFullFilePath+ '' +NL+ ' are still present but are longer needed by the program.' +NL+ 'Click Yes to delete them all, click No to prompt for deletion of each one or Cancel to keep them.';
          end
          else
          begin
            sTxt:= 'One or more files or links created by MyApp, the first of which is: ' +sFullFilePath+ '' +NL+ ' are still present but are longer needed by the program.' +NL+ 'Click Yes to delete them all, click No to prompt for deletion of each one or Cancel to keep them.';
          end;
      end;
    end;  //case


   case MsgBox(sTxt, mbConfirmation, MB_YESNOCANCEL) of
     IDYES:
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 3;
        end
        else
        begin
        SucInDel:= -3;
        end;
     End;
     IDNO:
    // user pressed No
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 4;
        end
        else
        begin
        SucInDel:= -4;
        end;
    End;
    IDCANCEL:
    Begin
    // user pressed Cancel
      SucInDel:= 0;
    End;
   End; //case

  End
  else
  Begin
    if DeleteOneFile(sFullFilePath, isDir) = True Then
    begin
    SucInDel:= 1;
    end
    else
    begin
    SucInDel:= -1;
    end;
  end;

End;
Result:= SucInDel;
end;


//*********************************************************************************
//cycles through all files that match a spec and then
//asks the user if they would like to delete them.
//*********************************************************************************
procedure DeleteManyFiles(sPattern: String; doDir: Boolean);
var
 ExistsFD: Boolean;
 FindRec: TFindRec;
 fdCount: Integer;
 retVal: Integer;
 errRaised: Boolean;
 sPatternPath: String;
 FindRecName: String; 
 begin
fdCount:= -1;
errRaised:= False;
sPatternPath:= ExtractFilePath(sPattern); // + Str('\') not req'd
 //test to see if a files matching a pattern still exists. if they do exist then we
 //ask the user if they want to delete each one
 //PathD:= AddBackslash(ExpandConstant('{app}'))
 if FindFirst(ExpandConstant(sPattern), FindRec) then
  begin
   try
       if doDir = True then
       Begin
       repeat
       if (FindRec.Name <> '.') And (FindRec.Name <> '..') And (FindRec.Attributes and FILE_ATTRIBUTE_DIRECTORY <> 0) then
         //we found one directory that matches our wildcards
           Begin
            //FindFirst returns the name of the file with no path so must account for that
            FindRecName:= sPatternPath + FindRec.Name;
            ExistsFD:= DirExists(FindRecName);

            //ask to delete the found file
            if ExistsFD = true then
            begin
            case fdCount of
            //retval vaues
            //-4 fail on delete confirmMany RepeatPrompt true
            //-3 fail on delete confirmMany true
            //-2 fail on delete confirm false
            //-1 fail on delete confirm true
            //no deletion here
            //1 succeed on delete confirm true
            //2 succeed on delete confirm false
            //3 succeed on delete confirmMany true
            //4 succeed on delete confirmMany RepeatPrompt true
           -1:
           begin
           retVal:= PrepDeleteOneFile(FindRecName, True, False, True);
           case retVal of
            0:
            begin
                Exit;
            end;
            3:
            begin
               fdCount:= 0;
            end;
            4:
            begin
                fdCount:= -1;
                //redundant but not sure about Continue statement and the "Until" condition
            end;
            else
            begin
               //An error continues the prompt
               ErrMsg(FindRecName);
            end;
           End; //case
           End;

           0:
           Begin
           retVal:= PrepDeleteOneFile(FindRecName, True, True, False);
           case retVal of
           0:
           begin
               Exit;
           end;
           1:
           begin
               fdCount:= 0; 
           end;
           2:
           begin
               fdCount:= -1;
           end;
           else
           begin
               fdCount:= -1;
               ErrMsg(FindRecName);
           end;
           End; //case

           End;
           else
           // just delete
           begin
           Sleep(10); //give the FS a break!
           if PrepDeleteOneFile(FindRecName, True, False, False) < 0 then
           begin
           fdCount:= -1;
           ErrMsg(FindRecName);
           end;
           end;


           End; //case
           fdCount:= fdCount + 1;
        End; //end if exists
            
        End;
       until not FindNext(FindRec);
       End



 



       Else
       Begin
       repeat
         if FindRec.Attributes And FILE_ATTRIBUTE_DIRECTORY = 0 then
         begin
           FindRecName:= sPatternPath + FindRec.Name;
           ExistsFD:= FileExists(FindRecName);
           if ExistsFD = true then
           begin
           case fdCount of
           -1:
           begin
           retVal:= PrepDeleteOneFile(FindRecName, False, False, True);
           case retVal of
            0:
            begin
                Exit;
             end;
            3:
            begin
               fdCount:= 0;
            end;
            4:
            begin
               fdCount:= -1;
            end;
            else
            begin
               ErrMsg(FindRecName);
            end;
           End; //case
           End;

           0:
           Begin
           retVal:= PrepDeleteOneFile(FindRecName, False, True, False);
           case retVal of
           0:
           begin
               Exit;
           end;
           1:
           begin
               fdCount:= 0;
           end;
           2:
           begin
               fdCount:= -1;
           end;
           else
           begin
               fdCount:= -1;
               ErrMsg(FindRecName);
           end;
           End; //case


           End;
           else
           //only check files and not directories
           begin
           Sleep(10);
           if PrepDeleteOneFile(FindRecName, False, False, False) < 0 then
           begin
           fdCount:= -1;
           ErrMsg(FindRecName);
           end;
           end;

           End; //case
           fdCount:= fdCount + 1;
           End; //end if exists

         End;
     until not FindNext(FindRec);
     End; //doDir
   finally
     FindClose(FindRec);
  end;
 end;
end;
// https://stackoverflow.com/questions/21143447/pascal-scripting-check-if-dest-directory-is-empty-and-only-print-yes-no-warnin
function isEmptyDir(dirName: String; DoDir: Boolean): Boolean;
var
  FindRec: TFindRec;
  FileStat: Boolean;
  DirStat: Boolean;
begin
  FileStat:= False;
  DirStat:= False;
  if FindFirst(dirName + '\*', FindRec) then
  begin
    try
      repeat
        if (FindRec.Name <> '.') And (FindRec.Name <> '..') And (FindRec.Attributes > 0) then
        begin
         if DoDir = True Then
          begin
          if FILE_ATTRIBUTE_DIRECTORY <> 0 then
          begin
          DirStat:= True;
          break;
          end;
         end
         else
          begin
          if FILE_ATTRIBUTE_DIRECTORY = 0 then
          //we found one file that matches our wildcards
          begin
          FileStat:= True;
          break;
          end;
          end;
        end;
      until not FindNext(FindRec);
    finally
      FindClose(FindRec);
      if (FileStat = False) And (DirStat = False) then
      Result:= True
      else
      Result:= False;
    end;
end;
end;

//*********************************************************************************
//deletes (with prompt) three individual files.
//deletes (with prompt) all files that match a pattern
//*********************************************************************************
procedure DeleteUserFiles();
var
 FileA: String;
 FileB: String;
 FileC: String;
 FileD: String;
 FileE: String;
 FileF: String;
 FileG: String;
 ExistsB: Boolean;
 ExistsC: Boolean;
 ExistsD: Boolean;
 ExistsE: Boolean;
 ExistsG: Boolean;
 begin
 //test to see if the INI file and LOG files still exist
 FileA:= ExpandConstant('{userprograms}\{#MyAppName}\*'); //'*' is not recommended
 FileB:= ExpandConstant('{userprograms}\{#MyAppName}');
 FileC:= ExpandConstant('{app}\{#MyAppName}.log');
 FileD:= ExpandConstant('{app}\Process.log');
 FileE:= ExpandConstant('{app}\{#MyAppUpdaterExeName}');
 FileF:= ExpandConstant('{app}\*'); //'*' is not recommended
 FileG:= ExpandConstant('{app}');
 ExistsB:= FileExists(FileB);
 ExistsC:= FileExists(FileC);
 ExistsD:= FileExists(FileD);
 ExistsE:= FileExists(FileE);
 ExistsG:= DirExists(FileG); 

 //ask to delete the INI and LOG files
 //if ExistsA = true then DeleteManyFiles(FileA);
 DeleteManyFiles(FileA, False);
 if (isEmptyDir(FileA, False) = False) And (ExistsB = true) then PrepDeleteOneFile(FileB, True, False, False);
 if ExistsC = true then PrepDeleteOneFile(FileC, False, False, False);
 if ExistsD = true then PrepDeleteOneFile(FileD, False, False, False);
 if ExistsE = true then PrepDeleteOneFile(FileE, False, False, False);
 //test to see if MDB files still exists. the MDB files are generated based on 
 //user ID so we cycle through all the existing databases in the app folder and
 //ask the user if they want to delete each one
 DeleteManyFiles(+FileG+ '??????XX.mdb', False);
 DeleteManyFiles(+FileG+ '{app}\??????YY.mdb', False);
 DeleteManyFiles(+FileG+ '{app}\??????ZZ.mdb', False);

 //Any Subfolders in MyApp?
 if isEmptyDir(FileG, True) = False Then
 Begin
  DeleteManyFiles(FileF, True);
 end;
end;



//repair/modify
//https://stackoverflow.com/questions/14446755/uninstall-when-running-inno-setup-with-application-already-installed
function ShowOptionsForm: TModalResult;
var
  OptionsForm: TSetupForm;
  RepairButton: TNewButton;
  UninstallButton: TNewButton;
begin
  Result := mrNone;
  OptionsForm := CreateCustomForm;
  try
    OptionsForm.Width := 220;
    OptionsForm.Caption := ExpandConstant('{cm:OptionsFormCaption}');
    OptionsForm.Position := poScreenCenter;

    RepairButton := TNewButton.Create(OptionsForm);
    RepairButton.Parent := OptionsForm;
    RepairButton.Left := 8;
    RepairButton.Top := 8;
    RepairButton.Width := OptionsForm.ClientWidth - 16;
    RepairButton.Caption := ExpandConstant('{cm:RepairButtonCaption}');
    RepairButton.ModalResult := mrRepair;

    UninstallButton := TNewButton.Create(OptionsForm);
    UninstallButton.Parent := OptionsForm;
    UninstallButton.Left := 8;
    UninstallButton.Top := RepairButton.Top + RepairButton.Height + 8;
    UninstallButton.Width := OptionsForm.ClientWidth - 16;
    UninstallButton.Caption := ExpandConstant('{cm:UninstallButtonCaption}');
    UninstallButton.ModalResult := mrUninstall;

    OptionsForm.ClientHeight := RepairButton.Height + UninstallButton.Height + 24;
    Result := OptionsForm.ShowModal;
  finally
    OptionsForm.Free;
  end;
end;
function GetUninstallerPath: string;
var
  RegKey: string;
begin
  Result := '';
  RegKey := ExpandConstant('Software\Microsoft\Windows\CurrentVersion\Uninstall\{#emit SetupSetting("AppId")}_is1');
  //RegKey := Format('%s\%s_is1', ['Software\Microsoft\Windows\CurrentVersion\Uninstall', '{#emit SetupSetting("AppId")}']);
  if not RegQueryStringValue(HKEY_LOCAL_MACHINE, RegKey, 'UninstallString', Result) then
    RegQueryStringValue(HKEY_CURRENT_USER, RegKey, 'UninstallString', Result);
end;





//*********************************************************************************
//this is the main calling point when the uninstall begins. we do this because the
//folder will be automatically be deleted at the END of this step, IF the folder no
//longer contains any files (or folders)
//*********************************************************************************
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
iResultCode: Integer;
begin
  if (CurUninstallStep=usUninstall) Then
   begin
      DeleteUserFiles;
      if MsgBox('Uninstallation of the ' + ExpandConstant('{#MyAppName}') + ' system files is strongly recommended. Continue?', mbConfirmation, MB_YESNO) = IDYES then
      begin
      if ShellExec('', ExpandConstant('{app}\unins001.exe'), '/SILENT /SUPPRESSMSGBOXES /lnch=lnchParent','', SW_SHOW, ewWaitUntilTerminated, iResultCode) = False then 
      MsgBox('There was an error with the ' + ExpandConstant('{#MyAppName}') + ' system files uninstallation. Code: ' + IntToStr(iResultCode) + '.', mbError, MB_OK);
      end;
   end;
end;
procedure CurPageChanged(CurPageID: Integer);
var
I: Integer;
begin
  if CurPageID = wpReady then
    begin
    WizardForm.ReadyLabel.Caption := 'Click Back to review/change settings, or Install to continue noting the following:' +NL+ '... Confirmation required on the next admin request to install ' + ExpandConstant('{#MyAppName}') + ' system files ...';
    end;
    if (CurPageID = wpFinished) and (not RunListModified) then
    begin
    { Add a dummy "Run nothing" entry: https://stackoverflow.com/questions/35539827/how-to-allow-only-one-checked-box-in-run-section }
    WizardForm.RunList.AddRadioButton('Run nothing', '', 0, True, True, -1);
    for I := 0 to WizardForm.RunList.Items.Count - 2 do
    begin
      { For all entries - take the first checkbox in the list, clone it to the end }
      { as a radio button with the same properties (mainly the caption and the object, }
      { which is actually index to the run list). }
      { Note that the ItemSubItem is always empty, ItemLevel always 0 and ItemEnabled }
      { always True. }
      WizardForm.RunList.AddRadioButton(
        WizardForm.RunList.ItemCaption[0],
        WizardForm.RunList.ItemSubItem[0],
        WizardForm.RunList.ItemLevel[0],
        False,
        WizardForm.RunList.ItemEnabled[0],
        WizardForm.RunList.ItemObject[0]);

      { And delete the original checkbox, pulling the next on to the first place }
      { for the next round. }
      WizardForm.RunList.Items.Delete(0);
    end;

    RunListModified := True;

    end;

end;

function NextButtonClick(CurPageID: Integer): Boolean;
begin
Result:= True
  if CurPageID = wpFinished then
  begin
    { Make sure we remove the dummy "Run nothing" entry, otherwise the Inno Setup fails }
    { processing it. }
    { The test for RunList.Count is for a case that a restart is needed and the RunList }
    { is never populated/shown. }
    { The test for ItemObject is here only in case we ever get here multiple time. }
    { But it should not really happen. }
    if (WizardForm.RunList.Items.Count > 0) and
       (Integer(WizardForm.RunList.ItemObject[0]) = -1) then
    begin
      WizardForm.RunList.Items.Delete(0);
    end;
  end;
end;
function InitializeSetup: Boolean;
var
  Language: string;
  UninstPath: string;
  ResultCode: Integer;  
begin

  // Modify Repair
  Language := ExpandConstant('{param:LANG}');
  UninstPath := RemoveQuotes(GetUninstallerPath);
  Result := True;

  if (UninstPath <> '') And (Language <> '') then
  begin
    case ShowOptionsForm of
      mrRepair:
      sleep(50);
      mrUninstall: 
      begin
        Result := False;
        if not Exec(UninstPath, '', '', SW_SHOW, ewNoWait, ResultCode) then
          MsgBox(FmtMessage(SetupMessage(msgUninstallOpenError), [UninstPath]), mbError, MB_OK);
        Exit;
      end;
    else //No options anyway but...
      begin
      Result := False;
      Exit;
      end;
    end;
  end;

  if (Language = '') And (GetWindowsVersion >= $05010000) then
  begin
     if IsAdminLoggedOn And (MsgBox('This installer is not intended to run under an Administrator account. Continue?', mbConfirmation, MB_YESNO) = IDNO) then
     begin
     Result := False;
     Exit;
     end;
  end;

    ExtractTemporaryFile('SapphireKamri.vsf');
    LoadVCLStyle(ExpandConstant('{tmp}\SapphireKamri.vsf'));


    if Language = '' then
      begin
        Log('No language specified, showing language dialog');
        SelectLanguage();
        Result := False;
        Exit;
      end
    else
      begin
      Log('Language specified, proceeding with installation');
      RunListModified := False;
      end;
end;
//for styles
procedure DeinitializeSetup();
begin
  UnLoadVCLStyles;
end;