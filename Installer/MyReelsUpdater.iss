; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
;See the wiki before packing!: https://github.com/lmstearn/MyReels/wiki
#define MyAppName "MyReels"
#define MyAppVersion "3.3.1"
#define MyAppPublisher "Stearn & DisAssoc"
#define MyAppURL "https://github.com/lmstearn/MyReels/wiki"
#define MyHomePage "http://members.ozemail.com.au/~lmstearn/"
#define MyAppDLURL "http://www.ozemail.com.au/~lmstearn/MyReelsStuff"
#define MyAppExeName "MyReels.exe"
#define MySetupAppExeName "SetupMyReels.exe"
#define MyAppUpdaterName "MyReelsUpdater"
#define MyAppUpdaterExeName "MyReelsUpdater.exe"
; Following usually C drive
#define MyUpdateDir "B:\games\"
;AppSupportURL
;AppUpdatesURL

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
PrivilegesRequired=admin
AppId={{7FE3CDE1-00A9-491F-B856-E3A121405B49}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
;AppMutex=20b70e57-1c2e-4de9-99e5-20f3961e6912
AppMutex=20b70e57-1c2e-4de9-99e5-20f3961e6812
CloseApplications=force
DefaultDirName={code:GetDefaultDir|Param}
DefaultGroupName={#MyAppName}
; Note: The Installer script resides in the Installer directory!
LicenseFile={#MyUpdateDir}{#MyAppName}\Installer\Licence.txt
OutputDir={#MyUpdateDir}{#MyAppName}\Installer
OutputBaseFilename={#MyAppUpdaterName}
Compression=lzma
SolidCompression=yes
SetupIconFile=CaveMantizardum.ico
WizardImageFile=Updated.bmp
;Using custom Language
ShowLanguageDialog=no
;Updater
;Uninstallable=No  ; fine as is
UsePreviousAppDir=yes
CreateUninstallRegKey=no
UpdateUninstallLogAppName=no
RestartIfNeededByRun=no
AppReadmeFile=Readme.txt
RestartApplications=False
MinVersion=0,5.01

[Files]
Source: "VclStylesinno.dll"; DestDir: "{app}"; Flags: dontcopy
Source: "SapphireKamri.vsf"; DestDir: "{app}"; Flags: dontcopy
Source: "{srcexe}"; DestDir: "{app}"; DestName: "{#MyAppUpdaterExeName}"; Flags: external skipifsourcedoesntexist ignoreversion replacesameversion restartreplace; Check: IsrunningNew

Source: "..\{#MyAppExeName}"; DestDir: "{app}"; Flags: touch ignoreversion replacesameversion; Components: program
Source: "Configuration\slotdata.s$t"; DestDir: "{app}"; Flags: touch ignoreversion replacesameversion; Components: quotes\configuration
Source: "..\{#MyAppName}.chm"; DestDir: "{app}"; Flags: touch ignoreversion replacesameversion; Components: help
Source: "..\Quotes.s$t"; DestDir: "{app}"; Flags: touch ignoreversion replacesameversion; Components: quotes

;Source: "Default\*.mid"; DestDir: "{app}"; Flags: touch; Components: midi\default
;Source: "Originals\*.mid"; DestDir: "{app}"; Flags: touch; Components: midi\original
;Source: "..\MyNewWavFile.wav"; DestDir: "{app}"; Flags: ignoreversion touch replacesameversion; Components: program
Source: "..\painter.wav"; DestDir: "{app}"; Flags: ignoreversion touch replacesameversion; Components: program

[Components]
Name: "program"; Description: "Program Files"; Types: full compact custom; Flags: fixed
Name: "quotes"; Description: "Quote File"; Types: full; Flags: disablenouninstallwarning
Name: "quotes\configuration"; Description: "s$t File. Required on updated Quotes file"; Types: full compact custom; Flags: disablenouninstallwarning
Name: "help"; Description: "Help File"; Types: full; Flags: disablenouninstallwarning
;Name: "midi"; Description: "Midi Files"; Types: full; Flags: disablenouninstallwarning
;Name: "midi/default"; Description: "Default"; Types: full; Flags: exclusive disablenouninstallwarning
;Name: "midi/original"; Description: "Originals (Monstrosities bundled with earlier versions)"; Types: full; Flags: exclusive disablenouninstallwarning

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent

[Languages]
Name: "en"; MessagesFile: "compiler:Default.isl"
Name: "cs"; MessagesFile: "compiler:Languages\Czech.isl"
Name: "deu"; MessagesFile: "compiler:Languages\German.isl"
Name: "es"; MessagesFile: "compiler:Languages\Spanish.isl"

[Messages]
WizardReady=Finalise Update
SetupWindowTitle=Update - %1
ClickNext=Click Next to continue, or Cancel to exit Update.
CustomInstallation=Custom Update
CompactInstallation=Compact Update
ExitSetupTitle=Exit Update
ExitSetupMessage=Update is not complete. If you exit now, the program will not be installed.%n%nYou may run Update again at another time to complete it.%n%nExit Update?
FullInstallation=Full Update
SelectComponentsLabel2=Select the components you want to update; clear the components you do not want to update. Click Next when you are ready to continue.
SelectLanguageLabel=Select the language to use during the Update:
LicenseLabel3=Please read the following License Agreement. You must accept the terms of this agreement before continuing with the Update.
SetupAppTitle=Update{#MyAppName}
WizardInstalling=Updating
WizardPreparing=Preparing to Update
ApplicationsFound2=The following applications are using files that need to be updated by Update. It is recommended that you allow Update to automatically close these applications. After the installation has completed, Update will attempt to restart the applications.
ReadyLabel2a=Click Continue to proceed with the Update, or click Back if you want to review or change any settings.
ReadyLabel1=Updating [name] on your computer.
FinishedHeadingLabel=Completing [name] Update
InstallingLabel=Please wait while [name] is updated on your computer.
SelectComponentsDesc=Which components should be updated?
FinishedLabelNoIcons=Setup has finished updating [name] on your computer.
ClickFinish=Click Finish to exit Update.
SelectLanguageTitle=Select Update Language

[Code]
#define DwinsHs_Data_Buffer_Length 8192
#include "dwinshs.iss"
const
   NL = #13#10;    //carriage return and line feed
   SetupURL = '{#MyAppDLURL}/{#MyAppUpdaterExeName}';
   VersionURL = '{#MyAppDLURL}/version.txt';
   MinVersion = '3.2.0'; //No conflict with MinVersion Directive above hopefully
   MOVEFILE_DELAY_UNTIL_REBOOT = $00000004;


   PreviousAppID = '7FE3CDE1-00A9-491F-B856-E3A121405B49';
   // The MyAppName SID

   UninstallPathApp = 'Software\Microsoft\Windows\CurrentVersion\Uninstall\{' + PreviousAppID + '}_is1';

   // Some posts have 'InstallDir', but never observed that
   InstallKey    = 'InstallLocation';

// Import the LoadVCLStyle function from VclStylesInno.DLL
procedure LoadVCLStyle(VClStyleFile: String); external 'LoadVCLStyleW@files:VclStylesInno.dll stdcall';
// Import the UnLoadVCLStyles function from VclStylesInno.DLL
procedure UnLoadVCLStyles; external 'UnLoadVCLStyles@files:VclStylesInno.dll stdcall';
function MoveFileEx (lpExistingFileName : string; lpNewFileName : string; dwFlags: Integer): Integer;
 external 'MoveFileExW@kernel32.dll stdcall';
function ShellExecute(hwnd: HWND; lpOperation: string; lpFile: string;
  lpParameters: string; lpDirectory: string; nShowCmd: Integer): THandle;
  external 'ShellExecuteW@shell32.dll stdcall';
  procedure ExitProcess(exitCode:integer); external 'ExitProcess@kernel32.dll stdcall';
  var
 DownloadIndicator: TNewProgressBar;
 BackClicked: Boolean; // stop D/L user hits back button
 Downloaded: Boolean; // hit back button when file is successfully D/LeD
 noInternet: Boolean;
 runningNew: Boolean;
 iResultCode : Integer;
 type //for Tlama's version code: https://stackoverflow.com/questions/22269116/inno-setup-check-for-new-updates
  TIntegerArray = array of Integer;
  TCompareResult = (crLesser, crEquals, crGreater);

function IsrunningNew(): Boolean;
begin
  if runningNew = True then Result := True
  else
  Result := False;
end;
// https://stackoverflow.com/questions/41021292/inno-setup-language-selector-with-vcl-styles/41021514#comment76511928_41021514
procedure SelectLanguage();
var
  LanguageForm: TSetupForm;
  CancelButton: TNewButton;
  OKButton: TNewButton;
  LangCombo: TNewComboBox;
  SelectLabel: TNewStaticText;
  Languages: TStrings;
  Instance: THandle;
  Params: string;
  P, I: Integer;
  S, L: string;
begin

  Languages := TStringList.Create();
  Languages.Add('en=English');
  Languages.Add('deu=German');
  Languages.Add('es=Spanish');
  Languages.Add('cs='+#$010C+'e'+#$0161+'tina');
  LanguageForm := CreateCustomForm;

  LanguageForm.Caption := SetupMessage(msgSelectLanguageTitle);
  LanguageForm.ClientWidth := ScaleX(297);
  LanguageForm.ClientHeight := ScaleY(125);
  LanguageForm.BorderStyle := bsDialog;
  LanguageForm.Center;

  CancelButton := TNewButton.Create(LanguageForm);
  CancelButton.Parent := LanguageForm;
  CancelButton.Left := ScaleX(214);
  CancelButton.Top := ScaleY(93);
  CancelButton.Width := ScaleY(75);
  CancelButton.Height := ScaleY(23);
  CancelButton.TabOrder := 3;
  CancelButton.ModalResult := mrCancel;
  CancelButton.Caption := SetupMessage(msgButtonCancel);

  OKButton := TNewButton.Create(LanguageForm);
  OKButton.Parent := LanguageForm;
  OKButton.Left := ScaleX(133);
  OKButton.Top := ScaleY(93);
  OKButton.Width := ScaleX(75);
  OKButton.Height := ScaleY(23);
  OKButton.Caption := SetupMessage(msgButtonOK);
  OKButton.Default := True
  OKButton.ModalResult := mrOK;
  OKButton.TabOrder := 2;

  LangCombo := TNewComboBox.Create(LanguageForm);
  LangCombo.Parent := LanguageForm;
  LangCombo.Left := ScaleX(16);
  LangCombo.Top := ScaleY(56);
  LangCombo.Width := ScaleX(273);
  LangCombo.Height := ScaleY(21);
  LangCombo.Style := csDropDownList;
  LangCombo.DropDownCount := 16;
  LangCombo.TabOrder := 1;

  SelectLabel := TNewStaticText.Create(LanguageForm);
  SelectLabel.Parent := LanguageForm;
  SelectLabel.Left := ScaleX(16);
  SelectLabel.Top := ScaleY(8);
  SelectLabel.Width := ScaleX(273);
  SelectLabel.Height := ScaleY(39);
  SelectLabel.AutoSize := False
  SelectLabel.Caption := SetupMessage(msgSelectLanguageLabel);
  SelectLabel.TabOrder := 0;
  SelectLabel.WordWrap := True;

  for I := 0 to Languages.Count - 1 do
  begin
    P := Pos('=', Languages.Strings[I]);
    L := Copy(Languages.Strings[I], 0, P - 1);
    S := Copy(Languages.Strings[I], P + 1, Length(Languages.Strings[I]) - P);
    LangCombo.Items.Add(S);
    if L = ActiveLanguage then LangCombo.ItemIndex := I;
    end;

  if LanguageForm.ShowModal = mrOK then
  begin
    { Collect current instance parameters }
    for I := 1 to ParamCount do
    begin
      S := ParamStr(I);
      { Unique log file name for the elevated instance }
      if CompareText(Copy(S, 1, 5), '/LOG=') = 0 then
      begin
        S := S + '-localized';
      end;
      { Do not pass our /SL5 switch }
      if CompareText(Copy(S, 1, 5), '/SL5=') <> 0 then
      begin
        Params := Params + AddQuotes(S) + ' ';
      end;
    end;

    L := Languages.Strings[LangCombo.ItemIndex];
    P := Pos('=', L);
    L := Copy(L, 0, P-1);

    { ... and add selected language }
    Params := Params + '/LANG=' + L;


    Instance := ShellExecute(0, '', ExpandConstant('{srcexe}'), Params, '', SW_SHOWNORMAL);
    //
    //
    if Instance <= 32 then
    begin
      MsgBox(
        Format({srcexe}+ 'Running installer with selected language failed. Code: %d', [Instance]),
        mbError, MB_OK);
    end;

  end;
end;

  
Function OpenBrowser(Url: string): Boolean;
var
  ErrorCode: Integer;
begin
Result:= ShellExec('open', Url, '', '', SW_SHOWNORMAL, ewNoWait, ErrorCode);
end;

procedure LinkClick(Sender: TObject);
begin
  OpenBrowser('http://www.han-soft.com/dwinshs.php');
end;

procedure InitializeWizard();
var
  Link: TLabel;
begin
if (noInternet = False) And (runningNew = False) then
Begin
Link:= TLabel.Create(PageFromId(wpReady));
Link.Parent := PageFromId(wpReady).Surface;
//Link.Left := ScaleX(220);
//Link.Top := ScaleY(200);
//Link.Width := ScaleX(180);
Link.Height := ScaleY(8);
WizardForm.ReadyMemo.height := WizardForm.ReadyMemo.height - Link.Height - ScaleY(4);
Link.Left := WizardForm.ReadyMemo.left;
Link.Top := WizardForm.ReadyMemo.top + WizardForm.ReadyMemo.height + ScaleY(4);
Link.Width := WizardForm.ReadyMemo.width;
//Link.Top := WizardForm.ReadyPage.ClientHeight - Link.ClientHeight - 8;
Link.Caption := 'D/L powered by DwinsHS';
Link.ParentFont := True;
Link.OnClick := @LinkClick;
Link.Font.Style := Link.Font.Style + [fsUnderline];
Link.Font.Color := clBlue;
Link.Cursor := crHand;

  // Create the download progress indicator
  DownloadIndicator := TNewProgressBar.Create(PageFromId(wpReady));
  DownloadIndicator.Left := ScaleX(20);
  DownloadIndicator.Top := ScaleY(200);
  DownloadIndicator.Width := ScaleX(200);
  DownloadIndicator.Height:= ScaleY(20);
  DownloadIndicator.Min := 0;
  DownloadIndicator.Parent := PageFromId(wpReady).Surface;
End;
end;
// The callback function for DwinsHs_ReadRemoteURL
function OnRead(URL, Agent: AnsiString; Method: TReadMethod; Index, TotalSize, ReadSize, 
  CurrentSize: {#BIG_INT}; var ReadStr: AnsiString): Boolean;
begin
  if Index = 0 then DownloadIndicator.Max := 100;
  DownloadIndicator.Position := (ReadSize * 100) div TotalSize; // Update the download progress indicator
  Result := not BackClicked; // Determine whether download was cancelled & Continue to download
end;

procedure CurPageChanged(CurPageID: Integer);
var
  Response: AnsiString;
  Size: {#BIG_INT};
  i: Integer;
  
  begin
  Case CurPageId of
  wpSelectComponents:
    begin
    if (noInternet = False) And (runningNew = False) then
      begin
      //uncheck all except first entry
        for i := 1 to WizardForm.ComponentsList.Items.Count - 1 do
        begin
        WizardForm.ComponentsList.Checked[i] :=False
        end;
      WizardForm.NextButton.OnClick(nil);
      end;
    end;
  wpSelectTasks:
    if (noInternet = False) And (runningNew = False) then
    WizardForm.NextButton.OnClick(nil);
  wpReady:
  begin
  WizardForm.NextButton.Caption := '&Continue';
  if (noInternet = False) And (runningNew = False) And (not Downloaded) then
    begin
    WizardForm.PageNameLabel.Caption := 'Update Download';
    // Initialize download progress indicator
    DownloadIndicator.Position := 0;
    BackClicked := False;
    // Disable to continue before download completes
    WizardForm.NextButton.Enabled := False;
    // Enable to continue after download successfully
    WizardForm.NextButton.Enabled := DwinsHs_ReadRemoteURL(SetupURL, 
      '', rmGet, Response, Size, '', @OnRead) = READ_OK;
    // Save the remote file if download successfully
    if WizardForm.NextButton.Enabled then
      SaveStringToFile(ExpandConstant('{tmp}\New{#MyAppUpdaterExeName}'), Response, False);
    // Or verify the remote response
      if Response = 'registered' then
      begin

      end;
    end;
  end;
  wpFinished:
  begin
    if (noInternet = False) Then
    Begin
      if (runningNew = False) then
      begin
      WizardForm.FinishedLabel.Caption := ExpandConstant('{#MyAppName}') + ' Updater downloaded!' +NL+ 'Click Continue to execute the updater but note: ' +NL+ 'The updater file itself will not be replaced' +NL+ 'with the newer version until the next time it is run.';
      WizardForm.RunList.Checked[0] := False;
      WizardForm.RunList.Visible := False;
      WizardForm.FinishedHeadingLabel.Caption := 'Updater Downloaded';
      WizardForm.NextButton.Caption := '&Continue';
      end
      else
      begin
      //
      iResultCode := MoveFileEx(ExpandConstant('{srcexe}'), '', MOVEFILE_DELAY_UNTIL_REBOOT);
      if iResultCode = 0 then
      MsgBox(ExpandConstant('{srcexe}') + NL + ' is not able to be deleted at next reboot! Reason code: ' + IntToStr(iResultCode) + '.', mbError, MB_OK);
      end;
    End;
  end;
  end;
end;

// DwinsHS: The callback function for DwinsHs_ReadRemoteURL
function BackButtonClick(CurPageID: Integer): Boolean;
begin
  Result := True;
  if (runningNew = False) And (noInternet = False) then BackClicked := True;
end;
//End: DwinHS


function NextButtonClick(CurPageID: Integer): Boolean;
begin
  Result := True;
  if (runningNew = False) And (noInternet = False) And (CurPageID=wpFinished) then
  begin
      iResultCode := ShellExecute(0, 'runas', ExpandConstant('{tmp}\New{#MyAppUpdaterExeName}'), ExpandConstant('/LANG={param:LANG}'), '', SW_SHOWNORMAL);
      //if Exec(ExpandConstant('{app}\New{#MyAppUpdaterExeName}'), ExpandConstant('/LANG={param:LANG}'), '', SW_SHOWNORMAL, ewNoWait, iResultCode) Then
      Sleep(300);
      if iResultCode <= 32 Then
      MsgBox('The ' + ExpandConstant('{#MyAppName}') + 'Updating file could not be launched! Reason code: ' + IntToStr(iResultCode) + '.', mbError, MB_OK);
  end;
end;


// Begin Tlama's version code
function Max(A, B: Integer): Integer;
begin
  if A > B then Result := A else Result := B;
end;

function CompareValue(A, B: Integer): TCompareResult;
begin
  if A = B then
    Result := crEquals
  else
  if A < B then
    Result := crLesser
  else
    Result := crGreater;
end;

function AddVersionChunk(const S: string; var A: TIntegerArray): Integer;
var
  Chunk: Integer;
begin
  Chunk := StrToIntDef(S, -1);
  if Chunk <> -1 then
  begin
    Result := GetArrayLength(A) + 1;
    SetArrayLength(A, Result);
    A[Result - 1] := Chunk;
  end
  else
    RaiseException('Invalid format of version string');
end;

function ParseVersionStr(const S: string; var A: TIntegerArray): Integer;
var
  I: Integer;
  Count: Integer;
  Index: Integer;
begin
  Count := 0;
  Index := 1;

  for I := 1 to Length(S) do
  begin
    case S[I] of
      '.':
      begin
        AddVersionChunk(Copy(S, Index, Count), A);
        Count := 0;
        Index := I + 1;
      end;
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
      begin
        Count := Count + 1;
      end;
    else
      RaiseException('Invalid char in version string');
    end;
  end;
  Result := AddVersionChunk(Copy(S, Index, Count), A);
end;

function GetVersionValue(const A: TIntegerArray; Index,
  Length: Integer): Integer;
begin
  Result := 0;
  if (Index >= 0) and (Index < Length) then
    Result := A[Index];
end;

function CompareVersionStr(const A, B: string): TCompareResult;
var
  I: Integer;
  VerLenA, VerLenB: Integer;
  VerIntA, VerIntB: TIntegerArray;
begin
  Result := crEquals;

  VerLenA := ParseVersionStr(A, VerIntA);
  VerLenB := ParseVersionStr(B, VerIntB);

  for I := 0 to Max(VerLenA, VerLenB) - 1 do
  begin
    Result := CompareValue(GetVersionValue(VerIntA, I, VerLenA),
      GetVersionValue(VerIntB, I, VerLenB));
    if Result <> crEquals then Exit;
  end;
end;

function DownloadFile(const URL: string; var Response: string): Boolean;
var
  WinHttpRequest: Variant;
begin
  Result := True;
   try
    WinHttpRequest := CreateOleObject('WinHttp.WinHttpRequest.5.1');
    WinHttpRequest.Open('GET', URL, False);
   except
    Result := False;
    Response := GetExceptionMessage;
    Exit;
    end;
   try
    WinHttpRequest.Send;
   except
    Result := False;
    Exit;
    Response := GetExceptionMessage;
    end;
   try
    Response := WinHttpRequest.ResponseText;
   except
    Result := False;
    Response := GetExceptionMessage;
  end;
end;

function ShouldSkipPage(curPageId : Integer) : Boolean;
begin
  {For a certain condition, skip to wpFinished}
  Result := False;
 //To overcome DwinsHS progress bar not updating consider CurPageChange event instead.
 // if (runningNew = False) then
 //   begin
 //   //And (curPageId <> wpReady)
    
 //   if (curPageId = wpFinished) Then
 //     begin
 //     Result := True;
 //     //if (curPageId <> wpPreparing) And (curPageId <> wpReady) And (curPageId <> wpWelcome) Then Result := True;
 //     //MsgBox('curPageId: ' + IntToStr(curPageId) + ' wpReady: ' + IntToStr(wpReady) + ' wpWelcome: ' + IntToStr(wpWelcome), mbError, MB_OK);
 //     end;
 //   end
 // else
if (runningNew = True) then
    begin
    if (curPageId = wpWelcome) Or (curPageId = wpLicense) Then Result := True;
    end;
end;

function GetDefaultVer() : String;
var
   UserSIDs: TArrayOfString;
   I:        Integer;

begin
   // Check if the current user installed it
   if RegQueryStringValue( HKEY_CURRENT_USER, UninstallPathApp, 'DisplayVersion', Result) then

   // Current user didn't install it.  Did someone else?
   else if RegGetSubkeyNames( HKEY_USERS, '', UserSIDs ) then begin
      for I := 0 to GetArrayLength( UserSIDs ) - 1 do begin
         if RegQueryStringValue( HKEY_USERS, UserSIDs[I] + '\' + UninstallPathApp, 'DisplayVersion', Result) then break;
      end;  
   end;

   // Not installed per-user
   if Result = '' then begin
      // What about installed for the machine?
      RegQueryStringValue(HKEY_LOCAL_MACHINE, UninstallPathApp, 'DisplayVersion', Result);
      //Result : ''; Doesn't appear to be installed
   end;
end;

function InitializeSetup: Boolean;
var
  SetupVersion: string;
  LatestVersion: string;
  Language: string;
begin
  Downloaded := False;
  Result := True;
  noInternet := False
  //if ExpandConstant('{src}') = ExpandConstant('{tmp}') then
  if ExtractFileName(ExpandConstant('{srcexe}')) = ExpandConstant('{#MyAppUpdaterExeName}') then
  runningNew := False
  else
  runningNew := True;
  ExtractTemporaryFile('SapphireKamri.vsf');
  LoadVCLStyle(ExpandConstant('{tmp}\SapphireKamri.vsf'));
  Language := ExpandConstant('{param:LANG}');
  if Language = '' then
  begin
    Log('No language specified, showing language dialog');
    SelectLanguage();
    Result := False;
    Exit;
  end
    else
  begin
    Log('Language specified, proceeding with installation');
  end;

  if runningNew = True then
  //3.2 + full version required as some files have changed
  begin
    SetupVersion := GetDefaultVer;
    if SetupVersion = '' then
    begin
    MsgBox('Cannot retrieve version registry for ' + ExpandConstant('{#MyAppName}') + '!', mbError, MB_OK);
    Result := False;
    end
    else
    begin
      if CompareVersionStr(MinVersion, SetupVersion) = crGreater then
      begin
        Case MsgBox('The current version of ' + ExpandConstant('{#MyAppName}') + ' is too old to update!' +NL+ 'A repair install by the full 3.2+ version is now required.'+NL+ 'Note: Currently 3.2+ version unavailable so reply No.' +NL+ +NL+ 'Yes: Download it through your browser' +NL+ 'No: Continue with missing or superseded files (Not Recommended)' +NL+ 'Cancel: Cancel the update.', mbConfirmation, MB_YESNOCANCEL) of
        IDYES:
          begin
          if not OpenBrowser(ExpandConstant('{#MyAppDLURL}/{#MySetupAppExeName}')) then
          MsgBox('Download Failed!', mbError, MB_OK);
          end;
        IDNO:
          begin
          Result:= True;
          end;
        IDCANCEL:
          begin
          Result:= False;
          end;
        end;
      end;
    end;
  end
  else
  begin
  //Ancient versions will not have this key!
    if RegKeyExists(HKCU, ExpandConstant('SOFTWARE\{#MyAppPublisher}\{#MyAppName}')) then
    begin
      if DownloadFile(VersionURL, LatestVersion) then
      begin
      SetupVersion := '{#SetupSetting('AppVersion')}';
      if CompareVersionStr(LatestVersion, SetupVersion) = crGreater then
        begin
          case MsgBox('There is a newer version of this Updater available.' +NL+ 'Yes: Download and run it ' +NL+ 'No: Visit the site' +NL+ 'Cancel: Cancel the update', mbConfirmation, MB_YESNOCANCEL) of
          IDYES:
            begin
            Result:= True;
            end;
          IDNO:
            begin
            Result:= not OpenBrowser('{#MyHomePage}');
            end;
          else
            begin
            Result:= False
            end;
          end;
        end
        else
        begin
        MsgBox(ExpandConstant('{#MyAppName}') + ' is up to date!', mbInformation, MB_OK);
        Result:= False;
        end;

      end
      else
      begin
        if MsgBox('No connection to the internet detected!' +NL+ 'Do you wish to install this offline package update?', mbConfirmation, MB_YESNO) = IDYES Then
        noInternet:= True
        else
        Result:= False
      end;
    end
    else
    begin
    MsgBox(ExpandConstant('{#MyAppName}') + ' is not installed or there exists an old version of it. Please run the installer.', mbError, MB_OK);
    Result := False;
    end;
  end;
end;
//for styles
procedure DeinitializeSetup();
begin
  UnLoadVCLStyles;
end;


//
//The following is wiped from the original by the updater!
//

//*********************************************************************************
//gets language used in the setup. returns language code in lower case
//*********************************************************************************
function GetLangCode(): String;
begin
  Result:= Lowercase( ExpandConstant('{language}') )
end;
procedure ErrMsg(fName: String);
var
sTxt: String;
//error msg function
begin
  case GetLangCode of
     'es','es2': //spanish
    begin
        sTxt:= 'Se ha producido un error en la eliminación de ' +fname+ ': causa desconocida.';
    end;
    'deu':       //german
    begin
        sTxt:= 'Fehler löschen von ' +fname+ ': Ursache Unbekannt.';
    end;
  else          //en = the default is english or other unknown language
    begin
       sTxt:= 'Delete of ' +fname+ ' failed: Reason Unknown.';
    end;
  end;
MsgBox(sTxt, mbInformation, MB_OK);
end;
//**************************\\\
//***uninstallation stuff***\\\
//**************************\\\

//confirm file deletion and then delete the file
function DeleteOneFile(sFullFilePath: String; isDir: Boolean): Boolean;
begin
if (isDir = True) Then
  Result:= DelTree(sFullFilePath, True, True, True)
else
  Result:= DeleteFile(sFullFilePath);
end;
function PrepDeleteOneFile(sFullFilePath: String; isDir: Boolean; confirm: Boolean; confirmMany: Boolean): Integer;
// return value
//-4 fail on delete confirmMany RepeatPrompt true
//-3 fail on delete confirmMany true
//-2 fail on delete confirm false
//-1 fail on delete confirm true
//no deletion here
//1 succeed on delete confirm true
//2 succeed on delete confirm false
//3 succeed on delete confirmMany true
//4 succeed on delete confirmMany RepeatPrompt true
var
  sTxt: String;
  SucInDel: Integer;
begin
  //get language specific text strings
if confirm = true then
Begin

  case GetLangCode of
    'es','es2': //spanish
    begin
      if (isDir = True) Then
      Begin
        sTxt:= 'El elemento Directorio: ' +sFullFilePath+ '' +NL+ ' Todavía está presente pero ya no es necesario por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
      end
      else
      begin
        sTxt:= 'El elemento del archivo.' +NL+ ' Todavía está presente pero ya no es necesario por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
      end;
    end;
    'deu':       //german
    begin
      if (isDir = True) Then
      begin
        sTxt:= 'Das Verzeichnis item: ' +sFullFilePath+ '' +NL+ ' Ist noch verfügbar, aber länger verlangt vom Programm.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
      end
      else
      begin
        sTxt:= 'Das Dateiposition: ' +sFullFilePath+ '' +NL+ ' Ist noch verfügbar, aber länger verlangt vom Programm.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
      end;
    end;
  else          //en = the default is english or other unknown language
  Begin
     if (isDir = True) Then
     begin
     sTxt:= 'The Directory item: ' +sFullFilePath+ +NL+ 'and its contents are no longer needed by the program.' +NL+ 'Click Yes to delete all such ' + ExpandConstant('{#MyAppName}') + ' directories, click No to continue prompt for deletion of each directory or Cancel to keep them.';
     end
     else
     begin
     sTxt:= 'The file item: ' +sFullFilePath+ '' +NL+ 'is no longer needed by the program.' +NL+ 'Click Yes to delete all such ' + ExpandConstant('{#MyAppName}') + ' files, click No to continue prompt for deletion of each one or Cancel to keep them.';
     end;
  End;
  end; //case


  case MsgBox(sTxt, mbConfirmation, MB_YESNOCANCEL) of
  IDYES:
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 1;
        end
        else
        begin
        SucInDel:= -1;
        end;
     End;
  IDNO:
  // user pressed No
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 2;
        end
        else
        begin
        SucInDel:= -2;
        end;
     End;
  IDCANCEL:
     Begin
     // user pressed Cancel
     SucInDel:= 0;
     End;
  End;
End

Else
Begin

  if confirmMany = True then
  Begin
    case GetLangCode of
      'es','es2': //spanish
        begin
          if (isDir = True) Then
          Begin
            sTxt:= 'Uno o más directorios creados por ' + ExpandConstant('{#MyAppName}') + ', el primero de los cuales es: ' +sFullFilePath+ '' +NL+ ' Todavía están presentes pero son más necesarios por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
          end
          else
          begin
            sTxt:= 'Este Archivos o enlaces de usuario todavía está presente y ya no es necesario por el programa.' +NL+ ' Todavía están presentes pero son más necesarios por el programa.' +NL+ ' Haga clic en Sí para eliminarlos todos, haga clic en No para solicitar la eliminación de cada uno o en Cancelar para conservarlos.';
          end;
        end;   
      'deu':       //german
        begin
          if (isDir = True) Then
          begin
            sTxt:= 'Ein oder mehrere Verzeichnisse von ' + ExpandConstant('{#MyAppName}') + ' erstellt, die erste davon ist: ' +sFullFilePath+ '' +NL+ ' Sind noch vorhanden, werden aber länger vom Programm benötigt.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
          end
          else
          begin
            sTxt:= 'Ein oder mehrere Dateien oder Links von ' + ExpandConstant('{#MyAppName}') + ' erstellt, die erste davon ist: ' +sFullFilePath+ '' +NL+ '  Sind noch vorhanden, werden aber länger vom Programm benötigt.' +NL+ 'Klicken Sie auf Ja, um sie alle zu löschen, klicken Sie auf Nein, um zum Löschen von jedem aufzufordern oder Abbrechen, um sie zu behalten.';
          end;
        end;
      else          //en = the default is english or other unknown language
      begin
          if (isDir = True) Then
          begin
            sTxt:= 'One or more directories created by ' + ExpandConstant('{#MyAppName}') + ', the first of which is: ' +sFullFilePath+ '' +NL+ ' are still present but are longer needed by the program.' +NL+ 'Click Yes to delete them all, click No to prompt for deletion of each one or Cancel to keep them.';
          end
          else
          begin
            sTxt:= 'One or more files or links created by ' + ExpandConstant('{#MyAppName}') + ', the first of which is: ' +sFullFilePath+ '' +NL+ ' are still present but are longer needed by the program.' +NL+ 'Click Yes to delete them all, click No to prompt for deletion of each one or Cancel to keep them.';
          end;
      end;
    end;  //case


   case MsgBox(sTxt, mbConfirmation, MB_YESNOCANCEL) of
     IDYES:
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 3;
        end
        else
        begin
        SucInDel:= -3;
        end;
     End;
     IDNO:
    // user pressed No
     Begin
        if DeleteOneFile(sFullFilePath, isDir) = True Then
        begin
        SucInDel:= 4;
        end
        else
        begin
        SucInDel:= -4;
        end;
    End;
    IDCANCEL:
    Begin
    // user pressed Cancel
      SucInDel:= 0;
    End;
   End; //case

  End
  else
  Begin
    if DeleteOneFile(sFullFilePath, isDir) = True Then
    begin
    SucInDel:= 1;
    end
    else
    begin
    SucInDel:= -1;
    end;
  end;

End;
Result:= SucInDel;
end;


//*********************************************************************************
//cycles through all files that match a spec and then
//asks the user if they would like to delete them.
//*********************************************************************************
procedure DeleteManyFiles(sPattern: String; doDir: Boolean);
var
 ExistsFD: Boolean;
 FindRec: TFindRec;
 fdCount: Integer;
 retVal: Integer;
 errRaised: Boolean;
 sPatternPath: String;
 FindRecName: String; 
 begin
fdCount:= -1;
errRaised:= False;
sPatternPath:= ExtractFilePath(sPattern); // + Str('\') not req'd
 //test to see if a files matching a pattern still exists. if they do exist then we
 //ask the user if they want to delete each one
 //PathD:= AddBackslash(ExpandConstant('{app}'))
 if FindFirst(ExpandConstant(sPattern), FindRec) then
  begin
   try
       if doDir = True then
       Begin
       repeat
       if (FindRec.Name <> '.') And (FindRec.Name <> '..') And (FindRec.Attributes and FILE_ATTRIBUTE_DIRECTORY <> 0) then
         //we found one directory that matches our wildcards
           Begin
            //FindFirst returns the name of the file with no path so must account for that
            FindRecName:= sPatternPath + FindRec.Name;
            ExistsFD:= DirExists(FindRecName);

            //ask to delete the found file
            if ExistsFD = true then
            begin
            case fdCount of
            //retval vaues
            //-4 fail on delete confirmMany RepeatPrompt true
            //-3 fail on delete confirmMany true
            //-2 fail on delete confirm false
            //-1 fail on delete confirm true
            //no deletion here
            //1 succeed on delete confirm true
            //2 succeed on delete confirm false
            //3 succeed on delete confirmMany true
            //4 succeed on delete confirmMany RepeatPrompt true
           -1:
           begin
           retVal:= PrepDeleteOneFile(FindRecName, True, False, True);
           case retVal of
            0:
            begin
                Exit;
            end;
            3:
            begin
               fdCount:= 0;
            end;
            4:
            begin
                fdCount:= -1;
                //redundant but not sure about Continue statement and the "Until" condition
            end;
            else
            begin
               //An error continues the prompt
               ErrMsg(FindRecName);
            end;
           End; //case
           End;

           0:
           Begin
           retVal:= PrepDeleteOneFile(FindRecName, True, True, False);
           case retVal of
           0:
           begin
               Exit;
           end;
           1:
           begin
               fdCount:= 0; 
           end;
           2:
           begin
               fdCount:= -1;
           end;
           else
           begin
               fdCount:= -1;
               ErrMsg(FindRecName);
           end;
           End; //case

           End;
           else
           // just delete
           begin
           Sleep(10); //give the FS a break!
           if PrepDeleteOneFile(FindRecName, True, False, False) < 0 then
           begin
           fdCount:= -1;
           ErrMsg(FindRecName);
           end;
           end;


           End; //case
           fdCount:= fdCount + 1;
        End; //end if exists
            
        End;
       until not FindNext(FindRec);
       End



 



       Else
       Begin
       repeat
         if FindRec.Attributes And FILE_ATTRIBUTE_DIRECTORY = 0 then
         begin
           FindRecName:= sPatternPath + FindRec.Name;
           ExistsFD:= FileExists(FindRecName);
           if ExistsFD = true then
           begin
           case fdCount of
           -1:
           begin
           retVal:= PrepDeleteOneFile(FindRecName, False, False, True);
           case retVal of
            0:
            begin
                Exit;
             end;
            3:
            begin
               fdCount:= 0;
            end;
            4:
            begin
               fdCount:= -1;
            end;
            else
            begin
               ErrMsg(FindRecName);
            end;
           End; //case
           End;

           0:
           Begin
           retVal:= PrepDeleteOneFile(FindRecName, False, True, False);
           case retVal of
           0:
           begin
               Exit;
           end;
           1:
           begin
               fdCount:= 0;
           end;
           2:
           begin
               fdCount:= -1;
           end;
           else
           begin
               fdCount:= -1;
               ErrMsg(FindRecName);
           end;
           End; //case


           End;
           else
           //only check files and not directories
           begin
           Sleep(10);
           if PrepDeleteOneFile(FindRecName, False, False, False) < 0 then
           begin
           fdCount:= -1;
           ErrMsg(FindRecName);
           end;
           end;

           End; //case
           fdCount:= fdCount + 1;
           End; //end if exists

         End;
     until not FindNext(FindRec);
     End; //doDir
   finally
     FindClose(FindRec);
  end;
 end;
end;
// https://stackoverflow.com/questions/21143447/pascal-scripting-check-if-dest-directory-is-empty-and-only-print-yes-no-warnin
function isEmptyDir(dirName: String; DoDir: Boolean): Boolean;
var
  FindRec: TFindRec;
  FileStat: Boolean;
  DirStat: Boolean;
begin
  FileStat:= False;
  DirStat:= False;
  if FindFirst(dirName + '\*', FindRec) then
  begin
    try
      repeat
        if (FindRec.Name <> '.') And (FindRec.Name <> '..') And (FindRec.Attributes > 0) then
        begin
         if DoDir = True Then
          begin
          if FILE_ATTRIBUTE_DIRECTORY <> 0 then
          begin
          DirStat:= True;
          break;
          end;
         end
         else
          begin
          if FILE_ATTRIBUTE_DIRECTORY = 0 then
          //we found one file that matches our wildcards
          begin
          FileStat:= True;
          break;
          end;
          end;
        end;
      until not FindNext(FindRec);
    finally
      FindClose(FindRec);
      if (FileStat = False) And (DirStat = False) then
      Result:= True
      else
      Result:= False;
    end;
end;
end;

//*********************************************************************************
//deletes (with prompt) three individual files.
//deletes (with prompt) all files that match a pattern
//*********************************************************************************
procedure DeleteUserFiles();
var
 FileA: String;
 FileB: String;
 FileC: String;
 FileD: String;
 FileE: String;
 FileF: String;
 FileG: String;
 ExistsB: Boolean;
 ExistsC: Boolean;
 ExistsD: Boolean;
 ExistsE: Boolean;
 ExistsG: Boolean;
 begin
 //test to see if the INI file and LOG files still exist
 FileA:= ExpandConstant('{userprograms}\{#MyAppName}\*'); //'*' is not recommended
 FileB:= ExpandConstant('{userprograms}\{#MyAppName}');
 FileC:= ExpandConstant('{app}\{#MyAppName}.log');
 FileD:= ExpandConstant('{app}\Process.log');
 FileE:= ExpandConstant('{app}\{#MyAppUpdaterExeName}');
 FileF:= ExpandConstant('{app}\*'); //'*' is not recommended
 FileG:= ExpandConstant('{app}');
 ExistsB:= FileExists(FileB);
 ExistsC:= FileExists(FileC);
 ExistsD:= FileExists(FileD);
 ExistsE:= FileExists(FileE);
 ExistsG:= DirExists(FileG); 

 //ask to delete the INI and LOG files
 //if ExistsA = true then DeleteManyFiles(FileA);
 DeleteManyFiles(FileA, False);
 if (isEmptyDir(FileA, False) = False) And (ExistsB = true) then PrepDeleteOneFile(FileB, True, False, False);
 if ExistsC = true then PrepDeleteOneFile(FileC, False, False, False);
 if ExistsD = true then PrepDeleteOneFile(FileD, False, False, False);
 if ExistsE = true then PrepDeleteOneFile(FileE, False, False, False);
 //test to see if MDB files still exists. the MDB files are generated based on 
 //user ID so we cycle through all the existing databases in the app folder and
 //ask the user if they want to delete each one
 DeleteManyFiles(+FileG+ '??????XX.mdb', False);
 DeleteManyFiles(+FileG+ '{app}\??????YY.mdb', False);
 DeleteManyFiles(+FileG+ '{app}\??????ZZ.mdb', False);

 //Any Subfolders in MyApp?
 if isEmptyDir(FileG, True) = False Then
 Begin
 DeleteManyFiles(FileF, True);
 end;
end;

//*********************************************************************************
//this is the main calling point when the uninstall begins. we do this because the
//folder will be automatically be deleted at the END of this step, IF the folder no
//longer contains any files (or folders)
//*********************************************************************************
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
iResultCode: Integer;
begin
  if (CurUninstallStep=usUninstall) Then
   begin
      DeleteUserFiles;
      if MsgBox('Uninstallation of the ' + ExpandConstant('{#MyAppName}') + ' system files is strongly recommended. Continue?', mbConfirmation, MB_YESNO) = IDYES then
      begin
      if ShellExec('', ExpandConstant('{app}\unins001.exe'), '/SILENT /SUPPRESSMSGBOXES /lnch=lnchParent','', SW_SHOW, ewWaitUntilTerminated, iResultCode) = False then 
      MsgBox('There was an error with the ' + ExpandConstant('{#MyAppName}') + ' system files uninstallation. Code: ' + IntToStr(iResultCode) + '.', mbError, MB_OK);
      end;
   end;
end;

function GetDefaultDir( Param: String ) : String;
var
   UserSIDs: TArrayOfString;
   I:        Integer;

begin
   // Check if the current user installed it
   if RegQueryStringValue( HKEY_CURRENT_USER, UninstallPathApp, InstallKey, Result) then

   // Current user didn't install it.  Did someone else?
   else if RegGetSubkeyNames( HKEY_USERS, '', UserSIDs ) then begin
      for I := 0 to GetArrayLength( UserSIDs ) - 1 do begin
         if RegQueryStringValue( HKEY_USERS, UserSIDs[I] + '\' + UninstallPathApp, InstallKey, Result) then break;
      end;  
   end;

   // Not installed per-user
   if Result = '' then begin
      // What about installed for the machine?
      if RegQueryStringValue(HKEY_LOCAL_MACHINE, UninstallPathApp, InstallKey, Result) then

      // Doesn't appear to be installed, as admin default to Program Files
      else if IsAdminLoggedOn() then begin
         Result := ExpandConstant('{pf}\') + ExpandConstant('{#MyAppName}');

      // As non-admin, default to Local Application Data
      end else begin
         Result := ExpandConstant('{localappdata}\') + ExpandConstant('{#MyAppName}');
      end;
   end;
end;